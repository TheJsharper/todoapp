{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, inject, NgZone, Injectable, Inject, makeEnvironmentProviders, NgModule } from '@angular/core';\nimport * as i2 from '@ngrx/store';\nimport { ActionsSubject, UPDATE, INIT, INITIAL_STATE, StateObservable, ReducerManagerDispatcher } from '@ngrx/store';\nimport { EMPTY, Observable, of, merge, queueScheduler, ReplaySubject } from 'rxjs';\nimport { share, filter, map, concatMap, timeout, debounceTime, catchError, take, takeUntil, switchMap, skip, observeOn, withLatestFrom, scan } from 'rxjs/operators';\nimport { toSignal } from '@angular/core/rxjs-interop';\nconst PERFORM_ACTION = 'PERFORM_ACTION';\nconst REFRESH = 'REFRESH';\nconst RESET = 'RESET';\nconst ROLLBACK = 'ROLLBACK';\nconst COMMIT = 'COMMIT';\nconst SWEEP = 'SWEEP';\nconst TOGGLE_ACTION = 'TOGGLE_ACTION';\nconst SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nconst JUMP_TO_STATE = 'JUMP_TO_STATE';\nconst JUMP_TO_ACTION = 'JUMP_TO_ACTION';\nconst IMPORT_STATE = 'IMPORT_STATE';\nconst LOCK_CHANGES = 'LOCK_CHANGES';\nconst PAUSE_RECORDING = 'PAUSE_RECORDING';\nclass PerformAction {\n  constructor(action, timestamp) {\n    this.action = action;\n    this.timestamp = timestamp;\n    this.type = PERFORM_ACTION;\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n  }\n}\nclass Refresh {\n  constructor() {\n    this.type = REFRESH;\n  }\n}\nclass Reset {\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = RESET;\n  }\n}\nclass Rollback {\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = ROLLBACK;\n  }\n}\nclass Commit {\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = COMMIT;\n  }\n}\nclass Sweep {\n  constructor() {\n    this.type = SWEEP;\n  }\n}\nclass ToggleAction {\n  constructor(id) {\n    this.id = id;\n    this.type = TOGGLE_ACTION;\n  }\n}\nclass SetActionsActive {\n  constructor(start, end, active = true) {\n    this.start = start;\n    this.end = end;\n    this.active = active;\n    this.type = SET_ACTIONS_ACTIVE;\n  }\n}\nclass JumpToState {\n  constructor(index) {\n    this.index = index;\n    this.type = JUMP_TO_STATE;\n  }\n}\nclass JumpToAction {\n  constructor(actionId) {\n    this.actionId = actionId;\n    this.type = JUMP_TO_ACTION;\n  }\n}\nclass ImportState {\n  constructor(nextLiftedState) {\n    this.nextLiftedState = nextLiftedState;\n    this.type = IMPORT_STATE;\n  }\n}\nclass LockChanges {\n  constructor(status) {\n    this.status = status;\n    this.type = LOCK_CHANGES;\n  }\n}\nclass PauseRecording {\n  constructor(status) {\n    this.status = status;\n    this.type = PAUSE_RECORDING;\n  }\n}\n\n/**\n * Chrome extension documentation\n * @see https://github.com/reduxjs/redux-devtools/blob/main/extension/docs/API/Arguments.md\n * Firefox extension documentation\n * @see https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md\n */\nclass StoreDevtoolsConfig {\n  constructor() {\n    /**\n     * Maximum allowed actions to be stored in the history tree (default: `false`)\n     */\n    this.maxAge = false;\n  }\n}\nconst STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/store-devtools Options');\n/**\n * Used to provide a `StoreDevtoolsConfig` for the store-devtools.\n */\nconst INITIAL_OPTIONS = new InjectionToken('@ngrx/store-devtools Initial Config');\nfunction noMonitor() {\n  return null;\n}\nconst DEFAULT_NAME = 'NgRx Store DevTools';\nfunction createConfig(optionsInput) {\n  const DEFAULT_OPTIONS = {\n    maxAge: false,\n    monitor: noMonitor,\n    actionSanitizer: undefined,\n    stateSanitizer: undefined,\n    name: DEFAULT_NAME,\n    serialize: false,\n    logOnly: false,\n    autoPause: false,\n    trace: false,\n    traceLimit: 75,\n    // Add all features explicitly. This prevent buggy behavior for\n    // options like \"lock\" which might otherwise not show up.\n    features: {\n      pause: true,\n      // Start/pause recording of dispatched actions\n      lock: true,\n      // Lock/unlock dispatching actions and side effects\n      persist: true,\n      // Persist states on page reloading\n      export: true,\n      // Export history of actions in a file\n      import: 'custom',\n      // Import history of actions from a file\n      jump: true,\n      // Jump back and forth (time travelling)\n      skip: true,\n      // Skip (cancel) actions\n      reorder: true,\n      // Drag and drop actions in the history list\n      dispatch: true,\n      // Dispatch custom actions or action creators\n      test: true // Generate tests for the selected actions\n    },\n    connectInZone: false\n  };\n  const options = typeof optionsInput === 'function' ? optionsInput() : optionsInput;\n  const logOnly = options.logOnly ? {\n    pause: true,\n    export: true,\n    test: true\n  } : false;\n  const features = options.features || logOnly || DEFAULT_OPTIONS.features;\n  if (features.import === true) {\n    features.import = 'custom';\n  }\n  const config = Object.assign({}, DEFAULT_OPTIONS, {\n    features\n  }, options);\n  if (config.maxAge && config.maxAge < 2) {\n    throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`);\n  }\n  return config;\n}\nfunction difference(first, second) {\n  return first.filter(item => second.indexOf(item) < 0);\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\nfunction unliftState(liftedState) {\n  const {\n    computedStates,\n    currentStateIndex\n  } = liftedState;\n  // At start up NgRx dispatches init actions,\n  // When these init actions are being filtered out by the predicate or safe/block list options\n  // we don't have a complete computed states yet.\n  // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n  if (currentStateIndex >= computedStates.length) {\n    const {\n      state\n    } = computedStates[computedStates.length - 1];\n    return state;\n  }\n  const {\n    state\n  } = computedStates[currentStateIndex];\n  return state;\n}\nfunction unliftAction(liftedState) {\n  return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nfunction liftAction(action) {\n  return new PerformAction(action, +Date.now());\n}\n/**\n * Sanitizes given actions with given function.\n */\nfunction sanitizeActions(actionSanitizer, actions) {\n  return Object.keys(actions).reduce((sanitizedActions, actionIdx) => {\n    const idx = Number(actionIdx);\n    sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n    return sanitizedActions;\n  }, {});\n}\n/**\n * Sanitizes given action with given function.\n */\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n  return {\n    ...action,\n    action: actionSanitizer(action.action, actionIdx)\n  };\n}\n/**\n * Sanitizes given states with given function.\n */\nfunction sanitizeStates(stateSanitizer, states) {\n  return states.map((computedState, idx) => ({\n    state: sanitizeState(stateSanitizer, computedState.state, idx),\n    error: computedState.error\n  }));\n}\n/**\n * Sanitizes given state with given function.\n */\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n  return stateSanitizer(state, stateIdx);\n}\n/**\n * Read the config and tell if actions should be filtered\n */\nfunction shouldFilterActions(config) {\n  return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n/**\n * Return a full filtered lifted state\n */\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n  const filteredStagedActionIds = [];\n  const filteredActionsById = {};\n  const filteredComputedStates = [];\n  liftedState.stagedActionIds.forEach((id, idx) => {\n    const liftedAction = liftedState.actionsById[id];\n    if (!liftedAction) return;\n    if (idx && isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n      return;\n    }\n    filteredActionsById[id] = liftedAction;\n    filteredStagedActionIds.push(id);\n    filteredComputedStates.push(liftedState.computedStates[idx]);\n  });\n  return {\n    ...liftedState,\n    stagedActionIds: filteredStagedActionIds,\n    actionsById: filteredActionsById,\n    computedStates: filteredComputedStates\n  };\n}\n/**\n * Return true is the action should be ignored\n */\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n  const predicateMatch = predicate && !predicate(state, action.action);\n  const safelistMatch = safelist && !action.action.type.match(safelist.map(s => escapeRegExp(s)).join('|'));\n  const blocklistMatch = blockedlist && action.action.type.match(blockedlist.map(s => escapeRegExp(s)).join('|'));\n  return predicateMatch || safelistMatch || blocklistMatch;\n}\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n */\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction injectZoneConfig(connectInZone) {\n  const ngZone = connectInZone ? inject(NgZone) : null;\n  return {\n    ngZone,\n    connectInZone\n  };\n}\nlet DevtoolsDispatcher = /*#__PURE__*/(() => {\n  class DevtoolsDispatcher extends ActionsSubject {\n    /** @nocollapse */static {\n      this.ɵfac = /* @__PURE__ */(() => {\n        let ɵDevtoolsDispatcher_BaseFactory;\n        return function DevtoolsDispatcher_Factory(__ngFactoryType__) {\n          return (ɵDevtoolsDispatcher_BaseFactory || (ɵDevtoolsDispatcher_BaseFactory = i0.ɵɵgetInheritedFactory(DevtoolsDispatcher)))(__ngFactoryType__ || DevtoolsDispatcher);\n        };\n      })();\n    }\n    /** @nocollapse */\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: DevtoolsDispatcher,\n        factory: DevtoolsDispatcher.ɵfac\n      });\n    }\n  }\n  return DevtoolsDispatcher;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ExtensionActionTypes = {\n  START: 'START',\n  DISPATCH: 'DISPATCH',\n  STOP: 'STOP',\n  ACTION: 'ACTION'\n};\nconst REDUX_DEVTOOLS_EXTENSION = new InjectionToken('@ngrx/store-devtools Redux Devtools Extension');\nlet DevtoolsExtension = /*#__PURE__*/(() => {\n  class DevtoolsExtension {\n    constructor(devtoolsExtension, config, dispatcher) {\n      this.config = config;\n      this.dispatcher = dispatcher;\n      this.zoneConfig = injectZoneConfig(this.config.connectInZone);\n      this.devtoolsExtension = devtoolsExtension;\n      this.createActionStreams();\n    }\n    notify(action, state) {\n      if (!this.devtoolsExtension) {\n        return;\n      }\n      // Check to see if the action requires a full update of the liftedState.\n      // If it is a simple action generated by the user's app and the recording\n      // is not locked/paused, only send the action and the current state (fast).\n      //\n      // A full liftedState update (slow: serializes the entire liftedState) is\n      // only required when:\n      //   a) redux-devtools-extension fires the @@Init action (ignored by\n      //      @ngrx/store-devtools)\n      //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n      //      or @ngrx/store/update-reducers)\n      //   c) the state has been recomputed due to time-traveling\n      //   d) any action that is not a PerformAction to err on the side of\n      //      caution.\n      if (action.type === PERFORM_ACTION) {\n        if (state.isLocked || state.isPaused) {\n          return;\n        }\n        const currentState = unliftState(state);\n        if (shouldFilterActions(this.config) && isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n          return;\n        }\n        const sanitizedState = this.config.stateSanitizer ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex) : currentState;\n        const sanitizedAction = this.config.actionSanitizer ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId) : action;\n        this.sendToReduxDevtools(() => this.extensionConnection.send(sanitizedAction, sanitizedState));\n      } else {\n        // Requires full state update\n        const sanitizedLiftedState = {\n          ...state,\n          stagedActionIds: state.stagedActionIds,\n          actionsById: this.config.actionSanitizer ? sanitizeActions(this.config.actionSanitizer, state.actionsById) : state.actionsById,\n          computedStates: this.config.stateSanitizer ? sanitizeStates(this.config.stateSanitizer, state.computedStates) : state.computedStates\n        };\n        this.sendToReduxDevtools(() => this.devtoolsExtension.send(null, sanitizedLiftedState, this.getExtensionConfig(this.config)));\n      }\n    }\n    createChangesObservable() {\n      if (!this.devtoolsExtension) {\n        return EMPTY;\n      }\n      return new Observable(subscriber => {\n        const connection = this.zoneConfig.connectInZone ?\n        // To reduce change detection cycles, we need to run the `connect` method\n        // outside of the Angular zone. The `connect` method adds a `message`\n        // event listener to communicate with an extension using `window.postMessage`\n        // and handle message events.\n        this.zoneConfig.ngZone.runOutsideAngular(() => this.devtoolsExtension.connect(this.getExtensionConfig(this.config))) : this.devtoolsExtension.connect(this.getExtensionConfig(this.config));\n        this.extensionConnection = connection;\n        connection.init();\n        connection.subscribe(change => subscriber.next(change));\n        return connection.unsubscribe;\n      });\n    }\n    createActionStreams() {\n      // Listens to all changes\n      const changes$ = this.createChangesObservable().pipe(share());\n      // Listen for the start action\n      const start$ = changes$.pipe(filter(change => change.type === ExtensionActionTypes.START));\n      // Listen for the stop action\n      const stop$ = changes$.pipe(filter(change => change.type === ExtensionActionTypes.STOP));\n      // Listen for lifted actions\n      const liftedActions$ = changes$.pipe(filter(change => change.type === ExtensionActionTypes.DISPATCH), map(change => this.unwrapAction(change.payload)), concatMap(action => {\n        if (action.type === IMPORT_STATE) {\n          // State imports may happen in two situations:\n          // 1. Explicitly by user\n          // 2. User activated the \"persist state accross reloads\" option\n          //    and now the state is imported during reload.\n          // Because of option 2, we need to give possible\n          // lazy loaded reducers time to instantiate.\n          // As soon as there is no UPDATE action within 1 second,\n          // it is assumed that all reducers are loaded.\n          return this.dispatcher.pipe(filter(action => action.type === UPDATE), timeout(1000), debounceTime(1000), map(() => action), catchError(() => of(action)), take(1));\n        } else {\n          return of(action);\n        }\n      }));\n      // Listen for unlifted actions\n      const actions$ = changes$.pipe(filter(change => change.type === ExtensionActionTypes.ACTION), map(change => this.unwrapAction(change.payload)));\n      const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n      const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n      this.start$ = start$.pipe(takeUntil(stop$));\n      // Only take the action sources between the start/stop events\n      this.actions$ = this.start$.pipe(switchMap(() => actionsUntilStop$));\n      this.liftedActions$ = this.start$.pipe(switchMap(() => liftedUntilStop$));\n    }\n    unwrapAction(action) {\n      // indirect eval according to https://esbuild.github.io/content-types/#direct-eval\n      return typeof action === 'string' ? (0, eval)(`(${action})`) : action;\n    }\n    getExtensionConfig(config) {\n      const extensionOptions = {\n        name: config.name,\n        features: config.features,\n        serialize: config.serialize,\n        autoPause: config.autoPause ?? false,\n        trace: config.trace ?? false,\n        traceLimit: config.traceLimit ?? 75\n        // The action/state sanitizers are not added to the config\n        // because sanitation is done in this class already.\n        // It is done before sending it to the devtools extension for consistency:\n        // - If we call extensionConnection.send(...),\n        //   the extension would call the sanitizers.\n        // - If we call devtoolsExtension.send(...) (aka full state update),\n        //   the extension would NOT call the sanitizers, so we have to do it ourselves.\n      };\n      if (config.maxAge !== false /* support === 0 */) {\n        extensionOptions.maxAge = config.maxAge;\n      }\n      return extensionOptions;\n    }\n    sendToReduxDevtools(send) {\n      try {\n        send();\n      } catch (err) {\n        console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);\n      }\n    }\n    /** @nocollapse */\n    static {\n      this.ɵfac = function DevtoolsExtension_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || DevtoolsExtension)(i0.ɵɵinject(REDUX_DEVTOOLS_EXTENSION), i0.ɵɵinject(STORE_DEVTOOLS_CONFIG), i0.ɵɵinject(DevtoolsDispatcher));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: DevtoolsExtension,\n        factory: DevtoolsExtension.ɵfac\n      });\n    }\n  }\n  return DevtoolsExtension;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst INIT_ACTION = {\n  type: INIT\n};\nconst RECOMPUTE = '@ngrx/store-devtools/recompute';\nconst RECOMPUTE_ACTION = {\n  type: RECOMPUTE\n};\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry(reducer, action, state, error, errorHandler) {\n  if (error) {\n    return {\n      state,\n      error: 'Interrupted by an error up the chain'\n    };\n  }\n  let nextState = state;\n  let nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    errorHandler.handleError(err);\n  }\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  // If the recording is paused, recompute all states up until the pause state,\n  // else recompute all states.\n  const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n  for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n    const actionId = stagedActionIds[i];\n    const action = actionsById[actionId].action;\n    const previousEntry = nextComputedStates[i - 1];\n    const previousState = previousEntry ? previousEntry.state : committedState;\n    const previousError = previousEntry ? previousEntry.error : undefined;\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    const entry = shouldSkip ? previousEntry : computeNextEntry(reducer, action, previousState, previousError, errorHandler);\n    nextComputedStates.push(entry);\n  }\n  // If the recording is paused, the last state will not be recomputed,\n  // because it's essentially not part of the state history.\n  if (isPaused) {\n    nextComputedStates.push(computedStates[computedStates.length - 1]);\n  }\n  return nextComputedStates;\n}\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n  return {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: false,\n    isPaused: false\n  };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer, options = {}) {\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return reducer => (liftedState, liftedAction) => {\n    let {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused\n    } = liftedState || initialLiftedState;\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = Object.create(actionsById);\n    }\n    function commitExcessActions(n) {\n      // Auto-commits n-number of excess actions.\n      let excess = n;\n      let idsToDelete = stagedActionIds.slice(1, excess + 1);\n      for (let i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n      skippedActionIds = skippedActionIds.filter(id => idsToDelete.indexOf(id) === -1);\n      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n    function commitChanges() {\n      // Consider the last committed state the new starting point.\n      // Squash any staged actions into a single committed state.\n      actionsById = {\n        0: liftAction(INIT_ACTION)\n      };\n      nextActionId = 1;\n      stagedActionIds = [0];\n      skippedActionIds = [];\n      committedState = computedStates[currentStateIndex].state;\n      currentStateIndex = 0;\n      computedStates = [];\n    }\n    // By default, aggressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n    let minInvalidatedStateIndex = 0;\n    switch (liftedAction.type) {\n      case LOCK_CHANGES:\n        {\n          isLocked = liftedAction.status;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n      case PAUSE_RECORDING:\n        {\n          isPaused = liftedAction.status;\n          if (isPaused) {\n            // Add a pause action to signal the devtools-user the recording is paused.\n            // The corresponding state will be overwritten on each update to always contain\n            // the latest state (see Actions.PERFORM_ACTION).\n            stagedActionIds = [...stagedActionIds, nextActionId];\n            actionsById[nextActionId] = new PerformAction({\n              type: '@ngrx/devtools/pause'\n            }, +Date.now());\n            nextActionId++;\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n            if (currentStateIndex === stagedActionIds.length - 2) {\n              currentStateIndex++;\n            }\n            minInvalidatedStateIndex = Infinity;\n          } else {\n            commitChanges();\n          }\n          break;\n        }\n      case RESET:\n        {\n          // Get back to the state the store was created with.\n          actionsById = {\n            0: liftAction(INIT_ACTION)\n          };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          committedState = initialCommittedState;\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n      case COMMIT:\n        {\n          commitChanges();\n          break;\n        }\n      case ROLLBACK:\n        {\n          // Forget about any staged actions.\n          // Start again from the last committed state.\n          actionsById = {\n            0: liftAction(INIT_ACTION)\n          };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n      case TOGGLE_ACTION:\n        {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const {\n            id: actionId\n          } = liftedAction;\n          const index = skippedActionIds.indexOf(actionId);\n          if (index === -1) {\n            skippedActionIds = [actionId, ...skippedActionIds];\n          } else {\n            skippedActionIds = skippedActionIds.filter(id => id !== actionId);\n          }\n          // Optimization: we know history before this action hasn't changed\n          minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n          break;\n        }\n      case SET_ACTIONS_ACTIVE:\n        {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const {\n            start,\n            end,\n            active\n          } = liftedAction;\n          const actionIds = [];\n          for (let i = start; i < end; i++) actionIds.push(i);\n          if (active) {\n            skippedActionIds = difference(skippedActionIds, actionIds);\n          } else {\n            skippedActionIds = [...skippedActionIds, ...actionIds];\n          }\n          // Optimization: we know history before this action hasn't changed\n          minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n          break;\n        }\n      case JUMP_TO_STATE:\n        {\n          // Without recomputing anything, move the pointer that tell us\n          // which state is considered the current one. Useful for sliders.\n          currentStateIndex = liftedAction.index;\n          // Optimization: we know the history has not changed.\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n      case JUMP_TO_ACTION:\n        {\n          // Jumps to a corresponding state to a specific action.\n          // Useful when filtering actions.\n          const index = stagedActionIds.indexOf(liftedAction.actionId);\n          if (index !== -1) currentStateIndex = index;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n      case SWEEP:\n        {\n          // Forget any actions that are currently being skipped.\n          stagedActionIds = difference(stagedActionIds, skippedActionIds);\n          skippedActionIds = [];\n          currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n          break;\n        }\n      case PERFORM_ACTION:\n        {\n          // Ignore action and return state as is if recording is locked\n          if (isLocked) {\n            return liftedState || initialLiftedState;\n          }\n          if (isPaused || liftedState && isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist)) {\n            // If recording is paused or if the action should be ignored, overwrite the last state\n            // (corresponds to the pause action) and keep everything else as is.\n            // This way, the app gets the new current state while the devtools\n            // do not record another action.\n            const lastState = computedStates[computedStates.length - 1];\n            computedStates = [...computedStates.slice(0, -1), computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler)];\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n          // Auto-commit as new actions come in.\n          if (options.maxAge && stagedActionIds.length === options.maxAge) {\n            commitExcessActions(1);\n          }\n          if (currentStateIndex === stagedActionIds.length - 1) {\n            currentStateIndex++;\n          }\n          const actionId = nextActionId++;\n          // Mutation! This is the hottest path, and we optimize on purpose.\n          // It is safe because we set a new key in a cache dictionary.\n          actionsById[actionId] = liftedAction;\n          stagedActionIds = [...stagedActionIds, actionId];\n          // Optimization: we know that only the new action needs computing.\n          minInvalidatedStateIndex = stagedActionIds.length - 1;\n          break;\n        }\n      case IMPORT_STATE:\n        {\n          // Completely replace everything.\n          ({\n            monitorState,\n            actionsById,\n            nextActionId,\n            stagedActionIds,\n            skippedActionIds,\n            committedState,\n            currentStateIndex,\n            computedStates,\n            isLocked,\n            isPaused\n          } = liftedAction.nextLiftedState);\n          break;\n        }\n      case INIT:\n        {\n          // Always recompute states on hot reload and init.\n          minInvalidatedStateIndex = 0;\n          if (options.maxAge && stagedActionIds.length > options.maxAge) {\n            // States must be recomputed before committing excess.\n            computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n            commitExcessActions(stagedActionIds.length - options.maxAge);\n            // Avoid double computation.\n            minInvalidatedStateIndex = Infinity;\n          }\n          break;\n        }\n      case UPDATE:\n        {\n          const stateHasErrors = computedStates.filter(state => state.error).length > 0;\n          if (stateHasErrors) {\n            // Recompute all states\n            minInvalidatedStateIndex = 0;\n            if (options.maxAge && stagedActionIds.length > options.maxAge) {\n              // States must be recomputed before committing excess.\n              computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n              commitExcessActions(stagedActionIds.length - options.maxAge);\n              // Avoid double computation.\n              minInvalidatedStateIndex = Infinity;\n            }\n          } else {\n            // If not paused/locked, add a new action to signal devtools-user\n            // that there was a reducer update.\n            if (!isPaused && !isLocked) {\n              if (currentStateIndex === stagedActionIds.length - 1) {\n                currentStateIndex++;\n              }\n              // Add a new action to only recompute state\n              const actionId = nextActionId++;\n              actionsById[actionId] = new PerformAction(liftedAction, +Date.now());\n              stagedActionIds = [...stagedActionIds, actionId];\n              minInvalidatedStateIndex = stagedActionIds.length - 1;\n              computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n            }\n            // Recompute state history with latest reducer and update action\n            computedStates = computedStates.map(cmp => ({\n              ...cmp,\n              state: reducer(cmp.state, RECOMPUTE_ACTION)\n            }));\n            currentStateIndex = stagedActionIds.length - 1;\n            if (options.maxAge && stagedActionIds.length > options.maxAge) {\n              commitExcessActions(stagedActionIds.length - options.maxAge);\n            }\n            // Avoid double computation.\n            minInvalidatedStateIndex = Infinity;\n          }\n          break;\n        }\n      default:\n        {\n          // If the action is not recognized, it's a monitor action.\n          // Optimization: a monitor action can't change history.\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n    }\n    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n    monitorState = monitorReducer(monitorState, liftedAction);\n    return {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused\n    };\n  };\n}\nlet StoreDevtools = /*#__PURE__*/(() => {\n  class StoreDevtools {\n    constructor(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {\n      const liftedInitialState = liftInitialState(initialState, config.monitor);\n      const liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);\n      const liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n      const liftedReducer$ = reducers$.pipe(map(liftReducer));\n      const zoneConfig = injectZoneConfig(config.connectInZone);\n      const liftedStateSubject = new ReplaySubject(1);\n      this.liftedStateSubscription = liftedAction$.pipe(withLatestFrom(liftedReducer$),\n      // The extension would post messages back outside of the Angular zone\n      // because we call `connect()` wrapped with `runOutsideAngular`. We run change\n      // detection only once at the end after all the required asynchronous tasks have\n      // been processed (for instance, `setInterval` scheduled by the `timeout` operator).\n      // We have to re-enter the Angular zone before the `scan` since it runs the reducer\n      // which must be run within the Angular zone.\n      emitInZone(zoneConfig), scan(({\n        state: liftedState\n      }, [action, reducer]) => {\n        let reducedLiftedState = reducer(liftedState, action);\n        // On full state update\n        // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n        if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n          reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);\n        }\n        // Extension should be sent the sanitized lifted state\n        extension.notify(action, reducedLiftedState);\n        return {\n          state: reducedLiftedState,\n          action\n        };\n      }, {\n        state: liftedInitialState,\n        action: null\n      })).subscribe(({\n        state,\n        action\n      }) => {\n        liftedStateSubject.next(state);\n        if (action.type === PERFORM_ACTION) {\n          const unliftedAction = action.action;\n          scannedActions.next(unliftedAction);\n        }\n      });\n      this.extensionStartSubscription = extension.start$.pipe(emitInZone(zoneConfig)).subscribe(() => {\n        this.refresh();\n      });\n      const liftedState$ = liftedStateSubject.asObservable();\n      const state$ = liftedState$.pipe(map(unliftState));\n      Object.defineProperty(state$, 'state', {\n        value: toSignal(state$, {\n          manualCleanup: true,\n          requireSync: true\n        })\n      });\n      this.dispatcher = dispatcher;\n      this.liftedState = liftedState$;\n      this.state = state$;\n    }\n    ngOnDestroy() {\n      // Even though the store devtools plugin is recommended to be\n      // used only in development mode, it can still cause a memory leak\n      // in microfrontend applications that are being created and destroyed\n      // multiple times during development. This results in excessive memory\n      // consumption, as it prevents entire apps from being garbage collected.\n      this.liftedStateSubscription.unsubscribe();\n      this.extensionStartSubscription.unsubscribe();\n    }\n    dispatch(action) {\n      this.dispatcher.next(action);\n    }\n    next(action) {\n      this.dispatcher.next(action);\n    }\n    error(error) {}\n    complete() {}\n    performAction(action) {\n      this.dispatch(new PerformAction(action, +Date.now()));\n    }\n    refresh() {\n      this.dispatch(new Refresh());\n    }\n    reset() {\n      this.dispatch(new Reset(+Date.now()));\n    }\n    rollback() {\n      this.dispatch(new Rollback(+Date.now()));\n    }\n    commit() {\n      this.dispatch(new Commit(+Date.now()));\n    }\n    sweep() {\n      this.dispatch(new Sweep());\n    }\n    toggleAction(id) {\n      this.dispatch(new ToggleAction(id));\n    }\n    jumpToAction(actionId) {\n      this.dispatch(new JumpToAction(actionId));\n    }\n    jumpToState(index) {\n      this.dispatch(new JumpToState(index));\n    }\n    importState(nextLiftedState) {\n      this.dispatch(new ImportState(nextLiftedState));\n    }\n    lockChanges(status) {\n      this.dispatch(new LockChanges(status));\n    }\n    pauseRecording(status) {\n      this.dispatch(new PauseRecording(status));\n    }\n    /** @nocollapse */\n    static {\n      this.ɵfac = function StoreDevtools_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || StoreDevtools)(i0.ɵɵinject(DevtoolsDispatcher), i0.ɵɵinject(i2.ActionsSubject), i0.ɵɵinject(i2.ReducerObservable), i0.ɵɵinject(DevtoolsExtension), i0.ɵɵinject(i2.ScannedActionsSubject), i0.ɵɵinject(i0.ErrorHandler), i0.ɵɵinject(INITIAL_STATE), i0.ɵɵinject(STORE_DEVTOOLS_CONFIG));\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: StoreDevtools,\n        factory: StoreDevtools.ɵfac\n      });\n    }\n  }\n  return StoreDevtools;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * If the devtools extension is connected out of the Angular zone,\n * this operator will emit all events within the zone.\n */\nfunction emitInZone({\n  ngZone,\n  connectInZone\n}) {\n  return source => connectInZone ? new Observable(subscriber => source.subscribe({\n    next: value => ngZone.run(() => subscriber.next(value)),\n    error: error => ngZone.run(() => subscriber.error(error)),\n    complete: () => ngZone.run(() => subscriber.complete())\n  })) : source;\n}\nconst IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('@ngrx/store-devtools Is Devtools Extension or Monitor Present');\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n  return Boolean(extension) || config.monitor !== noMonitor;\n}\nfunction createReduxDevtoolsExtension() {\n  const extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n  if (typeof window === 'object' && typeof window[extensionKey] !== 'undefined') {\n    return window[extensionKey];\n  } else {\n    return null;\n  }\n}\n/**\n * Provides developer tools and instrumentation for `Store`.\n *\n * @usageNotes\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideStoreDevtools({\n *       maxAge: 25,\n *       logOnly: !isDevMode(),\n *     }),\n *   ],\n * });\n * ```\n */\nfunction provideStoreDevtools(options = {}) {\n  return makeEnvironmentProviders([DevtoolsExtension, DevtoolsDispatcher, StoreDevtools, {\n    provide: INITIAL_OPTIONS,\n    useValue: options\n  }, {\n    provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n    deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n    useFactory: createIsExtensionOrMonitorPresent\n  }, {\n    provide: REDUX_DEVTOOLS_EXTENSION,\n    useFactory: createReduxDevtoolsExtension\n  }, {\n    provide: STORE_DEVTOOLS_CONFIG,\n    deps: [INITIAL_OPTIONS],\n    useFactory: createConfig\n  }, {\n    provide: StateObservable,\n    deps: [StoreDevtools],\n    useFactory: createStateObservable\n  }, {\n    provide: ReducerManagerDispatcher,\n    useExisting: DevtoolsDispatcher\n  }]);\n}\nfunction createStateObservable(devtools) {\n  return devtools.state;\n}\nlet StoreDevtoolsModule = /*#__PURE__*/(() => {\n  class StoreDevtoolsModule {\n    static instrument(options = {}) {\n      return {\n        ngModule: StoreDevtoolsModule,\n        providers: [provideStoreDevtools(options)]\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵfac = function StoreDevtoolsModule_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || StoreDevtoolsModule)();\n      };\n    }\n    /** @nocollapse */\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: StoreDevtoolsModule\n      });\n    }\n    /** @nocollapse */\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n    }\n  }\n  return StoreDevtoolsModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INITIAL_OPTIONS, RECOMPUTE, REDUX_DEVTOOLS_EXTENSION, StoreDevtools, StoreDevtoolsConfig, StoreDevtoolsModule, provideStoreDevtools };","map":{"version":3,"names":["i0","InjectionToken","inject","NgZone","Injectable","Inject","makeEnvironmentProviders","NgModule","i2","ActionsSubject","UPDATE","INIT","INITIAL_STATE","StateObservable","ReducerManagerDispatcher","EMPTY","Observable","of","merge","queueScheduler","ReplaySubject","share","filter","map","concatMap","timeout","debounceTime","catchError","take","takeUntil","switchMap","skip","observeOn","withLatestFrom","scan","toSignal","PERFORM_ACTION","REFRESH","RESET","ROLLBACK","COMMIT","SWEEP","TOGGLE_ACTION","SET_ACTIONS_ACTIVE","JUMP_TO_STATE","JUMP_TO_ACTION","IMPORT_STATE","LOCK_CHANGES","PAUSE_RECORDING","PerformAction","constructor","action","timestamp","type","Error","Refresh","Reset","Rollback","Commit","Sweep","ToggleAction","id","SetActionsActive","start","end","active","JumpToState","index","JumpToAction","actionId","ImportState","nextLiftedState","LockChanges","status","PauseRecording","StoreDevtoolsConfig","maxAge","STORE_DEVTOOLS_CONFIG","INITIAL_OPTIONS","noMonitor","DEFAULT_NAME","createConfig","optionsInput","DEFAULT_OPTIONS","monitor","actionSanitizer","undefined","stateSanitizer","name","serialize","logOnly","autoPause","trace","traceLimit","features","pause","lock","persist","export","import","jump","reorder","dispatch","test","connectInZone","options","config","Object","assign","difference","first","second","item","indexOf","unliftState","liftedState","computedStates","currentStateIndex","length","state","unliftAction","actionsById","nextActionId","liftAction","Date","now","sanitizeActions","actions","keys","reduce","sanitizedActions","actionIdx","idx","Number","sanitizeAction","sanitizeStates","states","computedState","sanitizeState","error","stateIdx","shouldFilterActions","predicate","actionsSafelist","actionsBlocklist","filterLiftedState","safelist","blocklist","filteredStagedActionIds","filteredActionsById","filteredComputedStates","stagedActionIds","forEach","liftedAction","isActionFiltered","push","blockedlist","predicateMatch","safelistMatch","match","s","escapeRegExp","join","blocklistMatch","replace","injectZoneConfig","ngZone","DevtoolsDispatcher","ɵfac","ɵDevtoolsDispatcher_BaseFactory","DevtoolsDispatcher_Factory","__ngFactoryType__","ɵɵgetInheritedFactory","ɵprov","ɵɵdefineInjectable","token","factory","ngDevMode","ExtensionActionTypes","START","DISPATCH","STOP","ACTION","REDUX_DEVTOOLS_EXTENSION","DevtoolsExtension","devtoolsExtension","dispatcher","zoneConfig","createActionStreams","notify","isLocked","isPaused","currentState","sanitizedState","sanitizedAction","sendToReduxDevtools","extensionConnection","send","sanitizedLiftedState","getExtensionConfig","createChangesObservable","subscriber","connection","runOutsideAngular","connect","init","subscribe","change","next","unsubscribe","changes$","pipe","start$","stop$","liftedActions$","unwrapAction","payload","actions$","actionsUntilStop$","liftedUntilStop$","eval","extensionOptions","err","console","warn","DevtoolsExtension_Factory","ɵɵinject","INIT_ACTION","RECOMPUTE","RECOMPUTE_ACTION","computeNextEntry","reducer","errorHandler","nextState","nextError","toString","handleError","recomputeStates","minInvalidatedStateIndex","committedState","skippedActionIds","nextComputedStates","slice","lastIncludedActionId","i","previousEntry","previousState","previousError","shouldSkip","entry","liftInitialState","initialCommittedState","monitorReducer","monitorState","liftReducerWith","initialLiftedState","create","commitExcessActions","n","excess","idsToDelete","commitChanges","Infinity","concat","actionIds","Math","min","lastState","stateHasErrors","cmp","StoreDevtools","reducers$","extension","scannedActions","initialState","liftedInitialState","liftReducer","liftedAction$","asObservable","liftedReducer$","liftedStateSubject","liftedStateSubscription","emitInZone","reducedLiftedState","unliftedAction","extensionStartSubscription","refresh","liftedState$","state$","defineProperty","value","manualCleanup","requireSync","ngOnDestroy","complete","performAction","reset","rollback","commit","sweep","toggleAction","jumpToAction","jumpToState","importState","lockChanges","pauseRecording","StoreDevtools_Factory","ReducerObservable","ScannedActionsSubject","ErrorHandler","source","run","IS_EXTENSION_OR_MONITOR_PRESENT","createIsExtensionOrMonitorPresent","Boolean","createReduxDevtoolsExtension","extensionKey","window","provideStoreDevtools","provide","useValue","deps","useFactory","createStateObservable","useExisting","devtools","StoreDevtoolsModule","instrument","ngModule","providers","StoreDevtoolsModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector"],"sources":["C:/Users/devloop/Desktop/merge-angular-repo/todoapp/node_modules/@ngrx/store-devtools/fesm2022/ngrx-store-devtools.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, inject, NgZone, Injectable, Inject, makeEnvironmentProviders, NgModule } from '@angular/core';\nimport * as i2 from '@ngrx/store';\nimport { ActionsSubject, UPDATE, INIT, INITIAL_STATE, StateObservable, ReducerManagerDispatcher } from '@ngrx/store';\nimport { EMPTY, Observable, of, merge, queueScheduler, ReplaySubject } from 'rxjs';\nimport { share, filter, map, concatMap, timeout, debounceTime, catchError, take, takeUntil, switchMap, skip, observeOn, withLatestFrom, scan } from 'rxjs/operators';\nimport { toSignal } from '@angular/core/rxjs-interop';\n\nconst PERFORM_ACTION = 'PERFORM_ACTION';\nconst REFRESH = 'REFRESH';\nconst RESET = 'RESET';\nconst ROLLBACK = 'ROLLBACK';\nconst COMMIT = 'COMMIT';\nconst SWEEP = 'SWEEP';\nconst TOGGLE_ACTION = 'TOGGLE_ACTION';\nconst SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nconst JUMP_TO_STATE = 'JUMP_TO_STATE';\nconst JUMP_TO_ACTION = 'JUMP_TO_ACTION';\nconst IMPORT_STATE = 'IMPORT_STATE';\nconst LOCK_CHANGES = 'LOCK_CHANGES';\nconst PAUSE_RECORDING = 'PAUSE_RECORDING';\nclass PerformAction {\n    constructor(action, timestamp) {\n        this.action = action;\n        this.timestamp = timestamp;\n        this.type = PERFORM_ACTION;\n        if (typeof action.type === 'undefined') {\n            throw new Error('Actions may not have an undefined \"type\" property. ' +\n                'Have you misspelled a constant?');\n        }\n    }\n}\nclass Refresh {\n    constructor() {\n        this.type = REFRESH;\n    }\n}\nclass Reset {\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n        this.type = RESET;\n    }\n}\nclass Rollback {\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n        this.type = ROLLBACK;\n    }\n}\nclass Commit {\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n        this.type = COMMIT;\n    }\n}\nclass Sweep {\n    constructor() {\n        this.type = SWEEP;\n    }\n}\nclass ToggleAction {\n    constructor(id) {\n        this.id = id;\n        this.type = TOGGLE_ACTION;\n    }\n}\nclass SetActionsActive {\n    constructor(start, end, active = true) {\n        this.start = start;\n        this.end = end;\n        this.active = active;\n        this.type = SET_ACTIONS_ACTIVE;\n    }\n}\nclass JumpToState {\n    constructor(index) {\n        this.index = index;\n        this.type = JUMP_TO_STATE;\n    }\n}\nclass JumpToAction {\n    constructor(actionId) {\n        this.actionId = actionId;\n        this.type = JUMP_TO_ACTION;\n    }\n}\nclass ImportState {\n    constructor(nextLiftedState) {\n        this.nextLiftedState = nextLiftedState;\n        this.type = IMPORT_STATE;\n    }\n}\nclass LockChanges {\n    constructor(status) {\n        this.status = status;\n        this.type = LOCK_CHANGES;\n    }\n}\nclass PauseRecording {\n    constructor(status) {\n        this.status = status;\n        this.type = PAUSE_RECORDING;\n    }\n}\n\n/**\n * Chrome extension documentation\n * @see https://github.com/reduxjs/redux-devtools/blob/main/extension/docs/API/Arguments.md\n * Firefox extension documentation\n * @see https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md\n */\nclass StoreDevtoolsConfig {\n    constructor() {\n        /**\n         * Maximum allowed actions to be stored in the history tree (default: `false`)\n         */\n        this.maxAge = false;\n    }\n}\nconst STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/store-devtools Options');\n/**\n * Used to provide a `StoreDevtoolsConfig` for the store-devtools.\n */\nconst INITIAL_OPTIONS = new InjectionToken('@ngrx/store-devtools Initial Config');\nfunction noMonitor() {\n    return null;\n}\nconst DEFAULT_NAME = 'NgRx Store DevTools';\nfunction createConfig(optionsInput) {\n    const DEFAULT_OPTIONS = {\n        maxAge: false,\n        monitor: noMonitor,\n        actionSanitizer: undefined,\n        stateSanitizer: undefined,\n        name: DEFAULT_NAME,\n        serialize: false,\n        logOnly: false,\n        autoPause: false,\n        trace: false,\n        traceLimit: 75,\n        // Add all features explicitly. This prevent buggy behavior for\n        // options like \"lock\" which might otherwise not show up.\n        features: {\n            pause: true, // Start/pause recording of dispatched actions\n            lock: true, // Lock/unlock dispatching actions and side effects\n            persist: true, // Persist states on page reloading\n            export: true, // Export history of actions in a file\n            import: 'custom', // Import history of actions from a file\n            jump: true, // Jump back and forth (time travelling)\n            skip: true, // Skip (cancel) actions\n            reorder: true, // Drag and drop actions in the history list\n            dispatch: true, // Dispatch custom actions or action creators\n            test: true, // Generate tests for the selected actions\n        },\n        connectInZone: false,\n    };\n    const options = typeof optionsInput === 'function' ? optionsInput() : optionsInput;\n    const logOnly = options.logOnly\n        ? { pause: true, export: true, test: true }\n        : false;\n    const features = options.features ||\n        logOnly ||\n        DEFAULT_OPTIONS.features;\n    if (features.import === true) {\n        features.import = 'custom';\n    }\n    const config = Object.assign({}, DEFAULT_OPTIONS, { features }, options);\n    if (config.maxAge && config.maxAge < 2) {\n        throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`);\n    }\n    return config;\n}\n\nfunction difference(first, second) {\n    return first.filter((item) => second.indexOf(item) < 0);\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\nfunction unliftState(liftedState) {\n    const { computedStates, currentStateIndex } = liftedState;\n    // At start up NgRx dispatches init actions,\n    // When these init actions are being filtered out by the predicate or safe/block list options\n    // we don't have a complete computed states yet.\n    // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n    if (currentStateIndex >= computedStates.length) {\n        const { state } = computedStates[computedStates.length - 1];\n        return state;\n    }\n    const { state } = computedStates[currentStateIndex];\n    return state;\n}\nfunction unliftAction(liftedState) {\n    return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nfunction liftAction(action) {\n    return new PerformAction(action, +Date.now());\n}\n/**\n * Sanitizes given actions with given function.\n */\nfunction sanitizeActions(actionSanitizer, actions) {\n    return Object.keys(actions).reduce((sanitizedActions, actionIdx) => {\n        const idx = Number(actionIdx);\n        sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n        return sanitizedActions;\n    }, {});\n}\n/**\n * Sanitizes given action with given function.\n */\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n    return {\n        ...action,\n        action: actionSanitizer(action.action, actionIdx),\n    };\n}\n/**\n * Sanitizes given states with given function.\n */\nfunction sanitizeStates(stateSanitizer, states) {\n    return states.map((computedState, idx) => ({\n        state: sanitizeState(stateSanitizer, computedState.state, idx),\n        error: computedState.error,\n    }));\n}\n/**\n * Sanitizes given state with given function.\n */\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n    return stateSanitizer(state, stateIdx);\n}\n/**\n * Read the config and tell if actions should be filtered\n */\nfunction shouldFilterActions(config) {\n    return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n/**\n * Return a full filtered lifted state\n */\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n    const filteredStagedActionIds = [];\n    const filteredActionsById = {};\n    const filteredComputedStates = [];\n    liftedState.stagedActionIds.forEach((id, idx) => {\n        const liftedAction = liftedState.actionsById[id];\n        if (!liftedAction)\n            return;\n        if (idx &&\n            isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n            return;\n        }\n        filteredActionsById[id] = liftedAction;\n        filteredStagedActionIds.push(id);\n        filteredComputedStates.push(liftedState.computedStates[idx]);\n    });\n    return {\n        ...liftedState,\n        stagedActionIds: filteredStagedActionIds,\n        actionsById: filteredActionsById,\n        computedStates: filteredComputedStates,\n    };\n}\n/**\n * Return true is the action should be ignored\n */\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n    const predicateMatch = predicate && !predicate(state, action.action);\n    const safelistMatch = safelist &&\n        !action.action.type.match(safelist.map((s) => escapeRegExp(s)).join('|'));\n    const blocklistMatch = blockedlist &&\n        action.action.type.match(blockedlist.map((s) => escapeRegExp(s)).join('|'));\n    return predicateMatch || safelistMatch || blocklistMatch;\n}\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n */\nfunction escapeRegExp(s) {\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nfunction injectZoneConfig(connectInZone) {\n    const ngZone = connectInZone ? inject(NgZone) : null;\n    return { ngZone, connectInZone };\n}\n\nclass DevtoolsDispatcher extends ActionsSubject {\n    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: DevtoolsDispatcher, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }\n    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: DevtoolsDispatcher }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: DevtoolsDispatcher, decorators: [{\n            type: Injectable\n        }] });\n\nconst ExtensionActionTypes = {\n    START: 'START',\n    DISPATCH: 'DISPATCH',\n    STOP: 'STOP',\n    ACTION: 'ACTION',\n};\nconst REDUX_DEVTOOLS_EXTENSION = new InjectionToken('@ngrx/store-devtools Redux Devtools Extension');\nclass DevtoolsExtension {\n    constructor(devtoolsExtension, config, dispatcher) {\n        this.config = config;\n        this.dispatcher = dispatcher;\n        this.zoneConfig = injectZoneConfig(this.config.connectInZone);\n        this.devtoolsExtension = devtoolsExtension;\n        this.createActionStreams();\n    }\n    notify(action, state) {\n        if (!this.devtoolsExtension) {\n            return;\n        }\n        // Check to see if the action requires a full update of the liftedState.\n        // If it is a simple action generated by the user's app and the recording\n        // is not locked/paused, only send the action and the current state (fast).\n        //\n        // A full liftedState update (slow: serializes the entire liftedState) is\n        // only required when:\n        //   a) redux-devtools-extension fires the @@Init action (ignored by\n        //      @ngrx/store-devtools)\n        //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n        //      or @ngrx/store/update-reducers)\n        //   c) the state has been recomputed due to time-traveling\n        //   d) any action that is not a PerformAction to err on the side of\n        //      caution.\n        if (action.type === PERFORM_ACTION) {\n            if (state.isLocked || state.isPaused) {\n                return;\n            }\n            const currentState = unliftState(state);\n            if (shouldFilterActions(this.config) &&\n                isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n                return;\n            }\n            const sanitizedState = this.config.stateSanitizer\n                ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex)\n                : currentState;\n            const sanitizedAction = this.config.actionSanitizer\n                ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId)\n                : action;\n            this.sendToReduxDevtools(() => this.extensionConnection.send(sanitizedAction, sanitizedState));\n        }\n        else {\n            // Requires full state update\n            const sanitizedLiftedState = {\n                ...state,\n                stagedActionIds: state.stagedActionIds,\n                actionsById: this.config.actionSanitizer\n                    ? sanitizeActions(this.config.actionSanitizer, state.actionsById)\n                    : state.actionsById,\n                computedStates: this.config.stateSanitizer\n                    ? sanitizeStates(this.config.stateSanitizer, state.computedStates)\n                    : state.computedStates,\n            };\n            this.sendToReduxDevtools(() => this.devtoolsExtension.send(null, sanitizedLiftedState, this.getExtensionConfig(this.config)));\n        }\n    }\n    createChangesObservable() {\n        if (!this.devtoolsExtension) {\n            return EMPTY;\n        }\n        return new Observable((subscriber) => {\n            const connection = this.zoneConfig.connectInZone\n                ? // To reduce change detection cycles, we need to run the `connect` method\n                    // outside of the Angular zone. The `connect` method adds a `message`\n                    // event listener to communicate with an extension using `window.postMessage`\n                    // and handle message events.\n                    this.zoneConfig.ngZone.runOutsideAngular(() => this.devtoolsExtension.connect(this.getExtensionConfig(this.config)))\n                : this.devtoolsExtension.connect(this.getExtensionConfig(this.config));\n            this.extensionConnection = connection;\n            connection.init();\n            connection.subscribe((change) => subscriber.next(change));\n            return connection.unsubscribe;\n        });\n    }\n    createActionStreams() {\n        // Listens to all changes\n        const changes$ = this.createChangesObservable().pipe(share());\n        // Listen for the start action\n        const start$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.START));\n        // Listen for the stop action\n        const stop$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.STOP));\n        // Listen for lifted actions\n        const liftedActions$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.DISPATCH), map((change) => this.unwrapAction(change.payload)), concatMap((action) => {\n            if (action.type === IMPORT_STATE) {\n                // State imports may happen in two situations:\n                // 1. Explicitly by user\n                // 2. User activated the \"persist state accross reloads\" option\n                //    and now the state is imported during reload.\n                // Because of option 2, we need to give possible\n                // lazy loaded reducers time to instantiate.\n                // As soon as there is no UPDATE action within 1 second,\n                // it is assumed that all reducers are loaded.\n                return this.dispatcher.pipe(filter((action) => action.type === UPDATE), timeout(1000), debounceTime(1000), map(() => action), catchError(() => of(action)), take(1));\n            }\n            else {\n                return of(action);\n            }\n        }));\n        // Listen for unlifted actions\n        const actions$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.ACTION), map((change) => this.unwrapAction(change.payload)));\n        const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n        const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n        this.start$ = start$.pipe(takeUntil(stop$));\n        // Only take the action sources between the start/stop events\n        this.actions$ = this.start$.pipe(switchMap(() => actionsUntilStop$));\n        this.liftedActions$ = this.start$.pipe(switchMap(() => liftedUntilStop$));\n    }\n    unwrapAction(action) {\n        // indirect eval according to https://esbuild.github.io/content-types/#direct-eval\n        return typeof action === 'string' ? (0, eval)(`(${action})`) : action;\n    }\n    getExtensionConfig(config) {\n        const extensionOptions = {\n            name: config.name,\n            features: config.features,\n            serialize: config.serialize,\n            autoPause: config.autoPause ?? false,\n            trace: config.trace ?? false,\n            traceLimit: config.traceLimit ?? 75,\n            // The action/state sanitizers are not added to the config\n            // because sanitation is done in this class already.\n            // It is done before sending it to the devtools extension for consistency:\n            // - If we call extensionConnection.send(...),\n            //   the extension would call the sanitizers.\n            // - If we call devtoolsExtension.send(...) (aka full state update),\n            //   the extension would NOT call the sanitizers, so we have to do it ourselves.\n        };\n        if (config.maxAge !== false /* support === 0 */) {\n            extensionOptions.maxAge = config.maxAge;\n        }\n        return extensionOptions;\n    }\n    sendToReduxDevtools(send) {\n        try {\n            send();\n        }\n        catch (err) {\n            console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);\n        }\n    }\n    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: DevtoolsExtension, deps: [{ token: REDUX_DEVTOOLS_EXTENSION }, { token: STORE_DEVTOOLS_CONFIG }, { token: DevtoolsDispatcher }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: DevtoolsExtension }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: DevtoolsExtension, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [REDUX_DEVTOOLS_EXTENSION]\n                }] }, { type: StoreDevtoolsConfig, decorators: [{\n                    type: Inject,\n                    args: [STORE_DEVTOOLS_CONFIG]\n                }] }, { type: DevtoolsDispatcher }] });\n\nconst INIT_ACTION = { type: INIT };\nconst RECOMPUTE = '@ngrx/store-devtools/recompute';\nconst RECOMPUTE_ACTION = { type: RECOMPUTE };\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry(reducer, action, state, error, errorHandler) {\n    if (error) {\n        return {\n            state,\n            error: 'Interrupted by an error up the chain',\n        };\n    }\n    let nextState = state;\n    let nextError;\n    try {\n        nextState = reducer(state, action);\n    }\n    catch (err) {\n        nextError = err.toString();\n        errorHandler.handleError(err);\n    }\n    return {\n        state: nextState,\n        error: nextError,\n    };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {\n    // Optimization: exit early and return the same reference\n    // if we know nothing could have changed.\n    if (minInvalidatedStateIndex >= computedStates.length &&\n        computedStates.length === stagedActionIds.length) {\n        return computedStates;\n    }\n    const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n    // If the recording is paused, recompute all states up until the pause state,\n    // else recompute all states.\n    const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n    for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n        const actionId = stagedActionIds[i];\n        const action = actionsById[actionId].action;\n        const previousEntry = nextComputedStates[i - 1];\n        const previousState = previousEntry ? previousEntry.state : committedState;\n        const previousError = previousEntry ? previousEntry.error : undefined;\n        const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n        const entry = shouldSkip\n            ? previousEntry\n            : computeNextEntry(reducer, action, previousState, previousError, errorHandler);\n        nextComputedStates.push(entry);\n    }\n    // If the recording is paused, the last state will not be recomputed,\n    // because it's essentially not part of the state history.\n    if (isPaused) {\n        nextComputedStates.push(computedStates[computedStates.length - 1]);\n    }\n    return nextComputedStates;\n}\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n    return {\n        monitorState: monitorReducer(undefined, {}),\n        nextActionId: 1,\n        actionsById: { 0: liftAction(INIT_ACTION) },\n        stagedActionIds: [0],\n        skippedActionIds: [],\n        committedState: initialCommittedState,\n        currentStateIndex: 0,\n        computedStates: [],\n        isLocked: false,\n        isPaused: false,\n    };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer, options = {}) {\n    /**\n     * Manages how the history actions modify the history state.\n     */\n    return (reducer) => (liftedState, liftedAction) => {\n        let { monitorState, actionsById, nextActionId, stagedActionIds, skippedActionIds, committedState, currentStateIndex, computedStates, isLocked, isPaused, } = liftedState || initialLiftedState;\n        if (!liftedState) {\n            // Prevent mutating initialLiftedState\n            actionsById = Object.create(actionsById);\n        }\n        function commitExcessActions(n) {\n            // Auto-commits n-number of excess actions.\n            let excess = n;\n            let idsToDelete = stagedActionIds.slice(1, excess + 1);\n            for (let i = 0; i < idsToDelete.length; i++) {\n                if (computedStates[i + 1].error) {\n                    // Stop if error is found. Commit actions up to error.\n                    excess = i;\n                    idsToDelete = stagedActionIds.slice(1, excess + 1);\n                    break;\n                }\n                else {\n                    delete actionsById[idsToDelete[i]];\n                }\n            }\n            skippedActionIds = skippedActionIds.filter((id) => idsToDelete.indexOf(id) === -1);\n            stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n            committedState = computedStates[excess].state;\n            computedStates = computedStates.slice(excess);\n            currentStateIndex =\n                currentStateIndex > excess ? currentStateIndex - excess : 0;\n        }\n        function commitChanges() {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = { 0: liftAction(INIT_ACTION) };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n        }\n        // By default, aggressively recompute every state whatever happens.\n        // This has O(n) performance, so we'll override this to a sensible\n        // value whenever we feel like we don't have to recompute the states.\n        let minInvalidatedStateIndex = 0;\n        switch (liftedAction.type) {\n            case LOCK_CHANGES: {\n                isLocked = liftedAction.status;\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case PAUSE_RECORDING: {\n                isPaused = liftedAction.status;\n                if (isPaused) {\n                    // Add a pause action to signal the devtools-user the recording is paused.\n                    // The corresponding state will be overwritten on each update to always contain\n                    // the latest state (see Actions.PERFORM_ACTION).\n                    stagedActionIds = [...stagedActionIds, nextActionId];\n                    actionsById[nextActionId] = new PerformAction({\n                        type: '@ngrx/devtools/pause',\n                    }, +Date.now());\n                    nextActionId++;\n                    minInvalidatedStateIndex = stagedActionIds.length - 1;\n                    computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n                    if (currentStateIndex === stagedActionIds.length - 2) {\n                        currentStateIndex++;\n                    }\n                    minInvalidatedStateIndex = Infinity;\n                }\n                else {\n                    commitChanges();\n                }\n                break;\n            }\n            case RESET: {\n                // Get back to the state the store was created with.\n                actionsById = { 0: liftAction(INIT_ACTION) };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                committedState = initialCommittedState;\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n            }\n            case COMMIT: {\n                commitChanges();\n                break;\n            }\n            case ROLLBACK: {\n                // Forget about any staged actions.\n                // Start again from the last committed state.\n                actionsById = { 0: liftAction(INIT_ACTION) };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n            }\n            case TOGGLE_ACTION: {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                const { id: actionId } = liftedAction;\n                const index = skippedActionIds.indexOf(actionId);\n                if (index === -1) {\n                    skippedActionIds = [actionId, ...skippedActionIds];\n                }\n                else {\n                    skippedActionIds = skippedActionIds.filter((id) => id !== actionId);\n                }\n                // Optimization: we know history before this action hasn't changed\n                minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n                break;\n            }\n            case SET_ACTIONS_ACTIVE: {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                const { start, end, active } = liftedAction;\n                const actionIds = [];\n                for (let i = start; i < end; i++)\n                    actionIds.push(i);\n                if (active) {\n                    skippedActionIds = difference(skippedActionIds, actionIds);\n                }\n                else {\n                    skippedActionIds = [...skippedActionIds, ...actionIds];\n                }\n                // Optimization: we know history before this action hasn't changed\n                minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n                break;\n            }\n            case JUMP_TO_STATE: {\n                // Without recomputing anything, move the pointer that tell us\n                // which state is considered the current one. Useful for sliders.\n                currentStateIndex = liftedAction.index;\n                // Optimization: we know the history has not changed.\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case JUMP_TO_ACTION: {\n                // Jumps to a corresponding state to a specific action.\n                // Useful when filtering actions.\n                const index = stagedActionIds.indexOf(liftedAction.actionId);\n                if (index !== -1)\n                    currentStateIndex = index;\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case SWEEP: {\n                // Forget any actions that are currently being skipped.\n                stagedActionIds = difference(stagedActionIds, skippedActionIds);\n                skippedActionIds = [];\n                currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n                break;\n            }\n            case PERFORM_ACTION: {\n                // Ignore action and return state as is if recording is locked\n                if (isLocked) {\n                    return liftedState || initialLiftedState;\n                }\n                if (isPaused ||\n                    (liftedState &&\n                        isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist))) {\n                    // If recording is paused or if the action should be ignored, overwrite the last state\n                    // (corresponds to the pause action) and keep everything else as is.\n                    // This way, the app gets the new current state while the devtools\n                    // do not record another action.\n                    const lastState = computedStates[computedStates.length - 1];\n                    computedStates = [\n                        ...computedStates.slice(0, -1),\n                        computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler),\n                    ];\n                    minInvalidatedStateIndex = Infinity;\n                    break;\n                }\n                // Auto-commit as new actions come in.\n                if (options.maxAge && stagedActionIds.length === options.maxAge) {\n                    commitExcessActions(1);\n                }\n                if (currentStateIndex === stagedActionIds.length - 1) {\n                    currentStateIndex++;\n                }\n                const actionId = nextActionId++;\n                // Mutation! This is the hottest path, and we optimize on purpose.\n                // It is safe because we set a new key in a cache dictionary.\n                actionsById[actionId] = liftedAction;\n                stagedActionIds = [...stagedActionIds, actionId];\n                // Optimization: we know that only the new action needs computing.\n                minInvalidatedStateIndex = stagedActionIds.length - 1;\n                break;\n            }\n            case IMPORT_STATE: {\n                // Completely replace everything.\n                ({\n                    monitorState,\n                    actionsById,\n                    nextActionId,\n                    stagedActionIds,\n                    skippedActionIds,\n                    committedState,\n                    currentStateIndex,\n                    computedStates,\n                    isLocked,\n                    isPaused,\n                } = liftedAction.nextLiftedState);\n                break;\n            }\n            case INIT: {\n                // Always recompute states on hot reload and init.\n                minInvalidatedStateIndex = 0;\n                if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                    // States must be recomputed before committing excess.\n                    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                    commitExcessActions(stagedActionIds.length - options.maxAge);\n                    // Avoid double computation.\n                    minInvalidatedStateIndex = Infinity;\n                }\n                break;\n            }\n            case UPDATE: {\n                const stateHasErrors = computedStates.filter((state) => state.error).length > 0;\n                if (stateHasErrors) {\n                    // Recompute all states\n                    minInvalidatedStateIndex = 0;\n                    if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                        // States must be recomputed before committing excess.\n                        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                        commitExcessActions(stagedActionIds.length - options.maxAge);\n                        // Avoid double computation.\n                        minInvalidatedStateIndex = Infinity;\n                    }\n                }\n                else {\n                    // If not paused/locked, add a new action to signal devtools-user\n                    // that there was a reducer update.\n                    if (!isPaused && !isLocked) {\n                        if (currentStateIndex === stagedActionIds.length - 1) {\n                            currentStateIndex++;\n                        }\n                        // Add a new action to only recompute state\n                        const actionId = nextActionId++;\n                        actionsById[actionId] = new PerformAction(liftedAction, +Date.now());\n                        stagedActionIds = [...stagedActionIds, actionId];\n                        minInvalidatedStateIndex = stagedActionIds.length - 1;\n                        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                    }\n                    // Recompute state history with latest reducer and update action\n                    computedStates = computedStates.map((cmp) => ({\n                        ...cmp,\n                        state: reducer(cmp.state, RECOMPUTE_ACTION),\n                    }));\n                    currentStateIndex = stagedActionIds.length - 1;\n                    if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                        commitExcessActions(stagedActionIds.length - options.maxAge);\n                    }\n                    // Avoid double computation.\n                    minInvalidatedStateIndex = Infinity;\n                }\n                break;\n            }\n            default: {\n                // If the action is not recognized, it's a monitor action.\n                // Optimization: a monitor action can't change history.\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n        }\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n        monitorState = monitorReducer(monitorState, liftedAction);\n        return {\n            monitorState,\n            actionsById,\n            nextActionId,\n            stagedActionIds,\n            skippedActionIds,\n            committedState,\n            currentStateIndex,\n            computedStates,\n            isLocked,\n            isPaused,\n        };\n    };\n}\n\nclass StoreDevtools {\n    constructor(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {\n        const liftedInitialState = liftInitialState(initialState, config.monitor);\n        const liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);\n        const liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n        const liftedReducer$ = reducers$.pipe(map(liftReducer));\n        const zoneConfig = injectZoneConfig(config.connectInZone);\n        const liftedStateSubject = new ReplaySubject(1);\n        this.liftedStateSubscription = liftedAction$\n            .pipe(withLatestFrom(liftedReducer$), \n        // The extension would post messages back outside of the Angular zone\n        // because we call `connect()` wrapped with `runOutsideAngular`. We run change\n        // detection only once at the end after all the required asynchronous tasks have\n        // been processed (for instance, `setInterval` scheduled by the `timeout` operator).\n        // We have to re-enter the Angular zone before the `scan` since it runs the reducer\n        // which must be run within the Angular zone.\n        emitInZone(zoneConfig), scan(({ state: liftedState }, [action, reducer]) => {\n            let reducedLiftedState = reducer(liftedState, action);\n            // On full state update\n            // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n            if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n                reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);\n            }\n            // Extension should be sent the sanitized lifted state\n            extension.notify(action, reducedLiftedState);\n            return { state: reducedLiftedState, action };\n        }, { state: liftedInitialState, action: null }))\n            .subscribe(({ state, action }) => {\n            liftedStateSubject.next(state);\n            if (action.type === PERFORM_ACTION) {\n                const unliftedAction = action.action;\n                scannedActions.next(unliftedAction);\n            }\n        });\n        this.extensionStartSubscription = extension.start$\n            .pipe(emitInZone(zoneConfig))\n            .subscribe(() => {\n            this.refresh();\n        });\n        const liftedState$ = liftedStateSubject.asObservable();\n        const state$ = liftedState$.pipe(map(unliftState));\n        Object.defineProperty(state$, 'state', {\n            value: toSignal(state$, { manualCleanup: true, requireSync: true }),\n        });\n        this.dispatcher = dispatcher;\n        this.liftedState = liftedState$;\n        this.state = state$;\n    }\n    ngOnDestroy() {\n        // Even though the store devtools plugin is recommended to be\n        // used only in development mode, it can still cause a memory leak\n        // in microfrontend applications that are being created and destroyed\n        // multiple times during development. This results in excessive memory\n        // consumption, as it prevents entire apps from being garbage collected.\n        this.liftedStateSubscription.unsubscribe();\n        this.extensionStartSubscription.unsubscribe();\n    }\n    dispatch(action) {\n        this.dispatcher.next(action);\n    }\n    next(action) {\n        this.dispatcher.next(action);\n    }\n    error(error) { }\n    complete() { }\n    performAction(action) {\n        this.dispatch(new PerformAction(action, +Date.now()));\n    }\n    refresh() {\n        this.dispatch(new Refresh());\n    }\n    reset() {\n        this.dispatch(new Reset(+Date.now()));\n    }\n    rollback() {\n        this.dispatch(new Rollback(+Date.now()));\n    }\n    commit() {\n        this.dispatch(new Commit(+Date.now()));\n    }\n    sweep() {\n        this.dispatch(new Sweep());\n    }\n    toggleAction(id) {\n        this.dispatch(new ToggleAction(id));\n    }\n    jumpToAction(actionId) {\n        this.dispatch(new JumpToAction(actionId));\n    }\n    jumpToState(index) {\n        this.dispatch(new JumpToState(index));\n    }\n    importState(nextLiftedState) {\n        this.dispatch(new ImportState(nextLiftedState));\n    }\n    lockChanges(status) {\n        this.dispatch(new LockChanges(status));\n    }\n    pauseRecording(status) {\n        this.dispatch(new PauseRecording(status));\n    }\n    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: StoreDevtools, deps: [{ token: DevtoolsDispatcher }, { token: i2.ActionsSubject }, { token: i2.ReducerObservable }, { token: DevtoolsExtension }, { token: i2.ScannedActionsSubject }, { token: i0.ErrorHandler }, { token: INITIAL_STATE }, { token: STORE_DEVTOOLS_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable }); }\n    /** @nocollapse */ static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: StoreDevtools }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: StoreDevtools, decorators: [{\n            type: Injectable\n        }], ctorParameters: () => [{ type: DevtoolsDispatcher }, { type: i2.ActionsSubject }, { type: i2.ReducerObservable }, { type: DevtoolsExtension }, { type: i2.ScannedActionsSubject }, { type: i0.ErrorHandler }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [INITIAL_STATE]\n                }] }, { type: StoreDevtoolsConfig, decorators: [{\n                    type: Inject,\n                    args: [STORE_DEVTOOLS_CONFIG]\n                }] }] });\n/**\n * If the devtools extension is connected out of the Angular zone,\n * this operator will emit all events within the zone.\n */\nfunction emitInZone({ ngZone, connectInZone, }) {\n    return (source) => connectInZone\n        ? new Observable((subscriber) => source.subscribe({\n            next: (value) => ngZone.run(() => subscriber.next(value)),\n            error: (error) => ngZone.run(() => subscriber.error(error)),\n            complete: () => ngZone.run(() => subscriber.complete()),\n        }))\n        : source;\n}\n\nconst IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('@ngrx/store-devtools Is Devtools Extension or Monitor Present');\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n    return Boolean(extension) || config.monitor !== noMonitor;\n}\nfunction createReduxDevtoolsExtension() {\n    const extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n    if (typeof window === 'object' &&\n        typeof window[extensionKey] !== 'undefined') {\n        return window[extensionKey];\n    }\n    else {\n        return null;\n    }\n}\n/**\n * Provides developer tools and instrumentation for `Store`.\n *\n * @usageNotes\n *\n * ```ts\n * bootstrapApplication(AppComponent, {\n *   providers: [\n *     provideStoreDevtools({\n *       maxAge: 25,\n *       logOnly: !isDevMode(),\n *     }),\n *   ],\n * });\n * ```\n */\nfunction provideStoreDevtools(options = {}) {\n    return makeEnvironmentProviders([\n        DevtoolsExtension,\n        DevtoolsDispatcher,\n        StoreDevtools,\n        {\n            provide: INITIAL_OPTIONS,\n            useValue: options,\n        },\n        {\n            provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n            deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n            useFactory: createIsExtensionOrMonitorPresent,\n        },\n        {\n            provide: REDUX_DEVTOOLS_EXTENSION,\n            useFactory: createReduxDevtoolsExtension,\n        },\n        {\n            provide: STORE_DEVTOOLS_CONFIG,\n            deps: [INITIAL_OPTIONS],\n            useFactory: createConfig,\n        },\n        {\n            provide: StateObservable,\n            deps: [StoreDevtools],\n            useFactory: createStateObservable,\n        },\n        {\n            provide: ReducerManagerDispatcher,\n            useExisting: DevtoolsDispatcher,\n        },\n    ]);\n}\n\nfunction createStateObservable(devtools) {\n    return devtools.state;\n}\nclass StoreDevtoolsModule {\n    static instrument(options = {}) {\n        return {\n            ngModule: StoreDevtoolsModule,\n            providers: [provideStoreDevtools(options)],\n        };\n    }\n    /** @nocollapse */ static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: StoreDevtoolsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    /** @nocollapse */ static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"18.2.5\", ngImport: i0, type: StoreDevtoolsModule }); }\n    /** @nocollapse */ static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: StoreDevtoolsModule }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.5\", ngImport: i0, type: StoreDevtoolsModule, decorators: [{\n            type: NgModule,\n            args: [{}]\n        }] });\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INITIAL_OPTIONS, RECOMPUTE, REDUX_DEVTOOLS_EXTENSION, StoreDevtools, StoreDevtoolsConfig, StoreDevtoolsModule, provideStoreDevtools };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}